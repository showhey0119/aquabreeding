'''
module for SNPs of parental/progeny populations
'''

import numpy as np
import msprime
from numba import jit


def genotype_array(snp_array):
    '''
    input snp_array, where rows: haplotype, columns: loci
    snp_array is generated by the function generate_snp_array
    SNPs are biallelic
    Genotypes are
    0: 0/0, 1: 0/1, 2: 1/1
    return np.array, where rows: genotypes, columns: loci
    '''
    cs_row, cs_column = np.shape(snp_array)
    cs_out = np.empty((0, cs_column), dtype=int)
    for cs_k in range(0, cs_row, 2):
        cs_tmp = snp_array[cs_k] + snp_array[cs_k+1]
        cs_out = np.append(cs_out, np.array([cs_tmp]), axis=0)
    return cs_out
    # genotpe_array


def progeny_snp(snp_array, snp_dict, n_snp, pro_pop, n_progeny):
    '''
    generating progeny's snp_array
    args: snp_array (founder), snp information, # snp, progeny_pop info
    return np.ndarray
    '''
    @jit(cache=True)
    def get_genotype(sp_ls, sp_pos):
        '''
        get genotype in a given chromosome position
        '''
        for sg_ls in sp_ls:
            if sg_ls[0] <= sp_pos <= sg_ls[1]:
                return sg_ls[2]
        return None
        # search genotype
    tmp_array = np.full((2*n_progeny, n_snp), -777, dtype=np.int)
    # for each SNP
    for ps_j in range(n_snp):
        ps_ch = snp_dict[ps_j]['chrom']
        ps_pos = snp_dict[ps_j]['pos']
        # for each progeny
        for ps_i in range(n_progeny):
            # get genotype
            ps_pat = get_genotype(pro_pop[ps_i].ch_ls[ps_ch].ch_pat, ps_pos)
            ps_mat = get_genotype(pro_pop[ps_i].ch_ls[ps_ch].ch_mat, ps_pos)
            tmp_array[2*ps_i][ps_j] = snp_array[ps_pat][ps_j]
            tmp_array[2*ps_i+1][ps_j] = snp_array[ps_mat][ps_j]
    return tmp_array
    # progeny_snp


def generate_snp(n_sample, n_snp, rate):
    '''
    generate independent SNPs
    return np.array
    rows: haplotype, columns: loci
    '''
    gsa_out = np.empty((0, 2*n_sample), dtype=np.int)
    gsa_count = 0  # until n_snp
    while True:
        gsa_ts = msprime.sim_ancestry(
            samples=n_sample,
            recombination_rate=rate[1],
            sequence_length=200,
            population_size=10_000)
        gsa_ts = msprime.sim_mutations(
                                gsa_ts,
                                rate=rate[0],
                                model=msprime.BinaryMutationModel(),
                                discrete_genome=False,
                                keep=False)
        for g_ts in gsa_ts.variants():
            tmp_gen = g_ts.genotypes
            gsa_out = np.append(gsa_out, np.array([tmp_gen]), axis=0)
            gsa_count += 1
            if gsa_count == n_snp:
                return gsa_out.T  # np.array
    # generate_snp_array


def main():
    '''
    main
    '''
    print('The module for population genetics')
    # main


if __name__ == '__main__':
    main()
