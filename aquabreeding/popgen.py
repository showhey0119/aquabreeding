'''
module for SNPs of parental/progeny populations
'''

import sys
import numpy as np
import msprime


def proportion_of_ibd(ls_1, ls_2, chrom):
    '''
    calculate the proportion of IBD regions
    args: paternal chromosome (list)
          maternal chromosome (list)
          tuple(chrom num, chrom len, cM/Mb)
    return prop IBD (float)
    '''
    pat_i = mat_i = 0
    homo_reg = 0.0
    beg_seg = 1
    end_seg = -777
    while True:
        if ls_1[pat_i][1] < ls_2[mat_i][1]:
            end_seg = ls_1[pat_i][1]
            if ls_1[pat_i][2] == ls_2[mat_i][2]:
                homo_reg += (end_seg - beg_seg + 1)
            pat_i += 1
            beg_seg = end_seg + 1
        else:
            end_seg = ls_2[mat_i][1]
            if ls_1[pat_i][2] == ls_2[mat_i][2]:
                homo_reg += (end_seg - beg_seg + 1)
            mat_i += 1
            beg_seg = end_seg + 1
        if end_seg == chrom[1]:
            break
    if homo_reg > chrom[1]:
        print(f'===\n{homo_reg}\n{ls_1}\n{ls_2}')
        sys.exit()
    return homo_reg
    # proportion_of_ibd


def gene_diversity(snp_array):
    '''
    calculate gene diversity from SNP array of the progenies
    args: snp_array (np.ndarray)
    return gene divesity (float), segregating site (int)
    '''
    n_row, n_col = np.shape(snp_array)
    hat_h = 0.0
    hat_s = 0
    for i in range(n_col):
        tmp_l = snp_array[:, i]
        f_0 = np.count_nonzero(tmp_l == 0)
        f_1 = np.count_nonzero(tmp_l == 1)
        hat_h += 2.0*f_0*f_1/n_row/(n_row-1.0)
        if f_0 > 0 and f_1 > 0:
            hat_s += 1
    hat_h /= n_col
    return hat_h, hat_s
    # gene_diversity


def genotype_array(snp_array):
    '''
    input snp_array, where rows: haplotype, columns: loci
    snp_array is generated by the function generate_snp_array
    SNPs are biallelic
    Genotypes are
    0: 0/0, 1: 0/1, 2: 1/1
    return np.array, where rows: genotypes, columns: loci
    '''
    cs_row, cs_column = np.shape(snp_array)
    cs_out = np.empty((0, cs_column), dtype=int)
    for cs_k in range(0, cs_row, 2):
        cs_tmp = snp_array[cs_k] + snp_array[cs_k+1]
        cs_out = np.append(cs_out, np.array([cs_tmp]), axis=0)
    return cs_out
    # genotpe_array


def get_genotype(sp_ls, sp_pos):
    '''
    get genotype in a given chromosome position
    '''
    for sg_ls in sp_ls:
        if sg_ls[0] <= sp_pos <= sg_ls[1]:
            return sg_ls[2]
    return None
    # get_genotype


def progeny_snp(snp_array, snp_dict, n_snp, pro_pop, n_progeny):
    '''
    generating progeny's snp_array
    args: snp_array (founder) (np.ndarray), snp information (dict),
          no. snp (int), progeny_pop (class list), progeny size (int)
    return np.ndarray
    '''
    tmp_array = np.full((2*n_progeny, n_snp), -777, dtype=np.int)
    # for each SNP
    for ps_j in range(n_snp):
        ps_ch = snp_dict[ps_j]['chrom']
        ps_pos = snp_dict[ps_j]['pos']
        # for each progeny
        for ps_i in range(n_progeny):
            # get genotype
            ps_pat = get_genotype(pro_pop[ps_i].ch_ls[ps_ch].ch_pat, ps_pos)
            ps_mat = get_genotype(pro_pop[ps_i].ch_ls[ps_ch].ch_mat, ps_pos)
            tmp_array[2*ps_i][ps_j] = snp_array[ps_pat][ps_j]
            tmp_array[2*ps_i+1][ps_j] = snp_array[ps_mat][ps_j]
    return tmp_array
    # progeny_snp


def generate_snp(n_sample, n_snp, rate):
    '''
    generate independent SNPs under standard
    Wright-Fisher model
    args: n_smaple: founder size (int)
          n_snp: the number of SNPs (int)
          rate: nuisance parameters
    return np.array (rows: haplotype, columns: loci)
    '''
    gsa_out = np.empty((0, 2*n_sample), dtype=np.int)
    gsa_count = 0  # until n_snp
    while True:
        gsa_ts = msprime.sim_ancestry(
            samples=n_sample,
            recombination_rate=rate[1],
            sequence_length=200,
            population_size=10_000)
        gsa_ts = msprime.sim_mutations(
                                gsa_ts,
                                rate=rate[0],
                                model=msprime.BinaryMutationModel(),
                                discrete_genome=False,
                                keep=False)
        for g_ts in gsa_ts.variants():
            tmp_gen = g_ts.genotypes
            gsa_out = np.append(gsa_out, np.array([tmp_gen]), axis=0)
            gsa_count += 1
            if gsa_count == n_snp:
                return gsa_out.T  # np.array
    # generate_snp_array


def main():
    '''
    main
    '''
    print('The module for population genetics')
    # main


if __name__ == '__main__':
    main()
